# Styling, PartialViews

<!-- vscode-markdown-toc -->
* 1. [Objectives](#Objectives)
* 2. [Applying Bootstrap Styles](#ApplyingBootstrapStyles)
* 3. [Partial Views](#PartialViews)
* 4. [Bibliography](#Bibliography)
* 5. [Creating a CRUD Controller](#CreatingaCRUDController)
* 6. [Implementing the List View](#ImplementingtheListView)
* 7. [Editing Products](#EditingProducts)
* 8. [Handling Edit POST Requests](#HandlingEditPOSTRequests)
* 9. [Adding model validation](#Addingmodelvalidation)
* 10. [Creating New Products](#CreatingNewProducts)
* 11. [Deleting Products](#DeletingProducts)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

##  1. <a name='Objectives'></a>Objectives

##  2. <a name='ApplyingBootstrapStyles'></a>Applying Bootstrap Styles

1. Add a new folder called `wwwroot` to the project.
2. Add the "Bootstrap" framework to your project by right clicking on the project and chosing "Add" > "Client Side Library". Use "cdnjs" as a provider and search for "twitter". 
3. Razor layouts provide common content so that it doesn’t have to be repeated in multiple views. Update the `_Layout.cshtml` file in the `Views/Shared` folder to include the Bootstrap CSS stylesheet in the content sent to the browser and define a common header that will be used throughout the application

    ```CSHTML
    <!DOCTYPE html>

    <html>
    <head>
        <meta name="viewport" content="width=device-width" />
        <title>@ViewBag.Title</title>

        <!-- !!!! new/updated code { -->
        <link href="/lib/twitter-bootstrap/css/bootstrap.min.css" rel="stylesheet" />
        <!-- } -->
    </head>
    <body>
        <!-- !!!! new/updated code { -->
        <div class="bg-dark text-white p-2">
            <span class="navbar-brand ml-2">MVC STORE</span>
        </div>
        <div class="row m-1 p-1">
            <div id="categories" class="col-3">
                Put something useful here later
            </div>
            <div class="col-9">
                @RenderBody()
            </div>
        </div>
        <!-- } -->
    </body>
    </html>
    ```
4. Also update the styling applied to the `Index.cshtml` file.

    ```CSHTML
    @model ProductsListViewModel

    @foreach (var p in Model.Products)
    {
        <div class="card card-outline-primary m-1 p-1">
            <div class="bg-faded p-1">
                <h4>
                    @p.Name
                    <span class="badge badge-pill badge-primary" style="float:right">
                        <small>@p.Price.ToString("c")</small>
                    </span>
                </h4>
            </div>
            <div class="card-text p-1">@p.Description</div>
        </div>
    }

    <div page-model="@Model.PagingInfo" 
        page-action="Index" 
        page-classes-enabled="true"
        page-class="btn" 
        page-class-normal="btn-outline-dark"
        page-class-selected="btn-primary" 
        class="btn-group pull-right m-1">
    </div>
    ```
5. We need to style the buttons generated by the `PageLinkTagHelper` class, but we don’t want to hardwire the Bootstrap classesinto the C# code because it makes it harder to reuse the tag helper elsewhere in the application or change the appearance of the buttons. Instead, we have defined custom attributes on the div element that specify the classes that we require, and these correspond to
properties we added to the tag helper class, which are then used to style the a elements that are produced.

    ```C#
    [HtmlTargetElement("div", Attributes = "page-model")]
    public class PageLinkTagHelper : TagHelper
    {
        private IUrlHelperFactory urlHelperFactory;
        public PageLinkTagHelper(IUrlHelperFactory helperFactory)
        {
            urlHelperFactory = helperFactory;
        }
        [ViewContext]
        [HtmlAttributeNotBound]
        public ViewContext ViewContext { get; set; }
        public PagingInfo PageModel { get; set; }
        public string PageAction { get; set; }

        // !!!! new/updated code {
        public bool PageClassesEnabled { get; set; } = false;
        public string PageClass { get; set; }
        public string PageClassNormal { get; set; }
        public string PageClassSelected { get; set; }
        //}

        public override void Process(TagHelperContext context, TagHelperOutput output)
        {
            IUrlHelper urlHelper = urlHelperFactory.GetUrlHelper(ViewContext);

            TagBuilder result = new TagBuilder("div");
            for (int i = 1; i <= PageModel.TotalPages; i++)
            {
                TagBuilder tag = new TagBuilder("a");
                tag.Attributes["href"] = urlHelper.Action(PageAction, new {productPage = i});

                // !!!! new/updated code {
                if (PageClassesEnabled) {
                    tag.AddCssClass(PageClass);
                    tag.AddCssClass(i == PageModel.CurrentPage? PageClassSelected : PageClassNormal);
                }
                //}

                tag.InnerHtml.Append(i.ToString());
                result.InnerHtml.AppendHtml(tag);
            }
            output.Content.AppendHtml(result.InnerHtml);
        }
    }
    ```

    > The values of the attributes are automatically used to set the tag helper property values, with the mapping between the HTML attribute name format  (page-class-normal) and the C# property name format (PageClassNormal) taken into account. This allows tag helpers to respond differently based on the attributes of an HTML element, creating a more flexible way to generate content in an ASP.NET Core application.

##  3. <a name='PartialViews'></a>Partial Views

6. Creating a Partial View. We would like to refactor the application to simplify the `Index.cshtml` view. We are going to create a partial view, which is a fragment of content that we can embed into another view, rather like a template. They help reduce duplication when you need the same content to appear in different places in an application. To create the partial view, we added a Razor View called `ProductSummary.cshtml` to the `Views/Shared` folder and added the markup shown below.

    ```CSHTML
    @model Product
    <div class="card card-outline-primary m-1 p-1">
        <div class="bg-faded p-1">
            <h4>
                @Model.Name
                <span class="badge badge-pill badge-primary" style="float:right">
                    <small>@Model.Price.ToString("c")</small>
                </span>
            </h4>
        </div>
        <div class="card-text p-1">@Model.Description</div>
    </div>
    ```
7. Update the `Index.cshtml` file in the `Views/Home` folder so that it uses the partial view.

    ```CSHTML
    @model ProductsListViewModel

    @foreach (var p in Model.Products)
    {
        <partial name="ProductSummary" model="p" />
    }

    <div page-model="@Model.PagingInfo" page-action="Index" page-classes-enabled="true"
        page-class="btn" page-class-normal="btn-outline-dark"
        page-class-selected="btn-primary" class="btn-group pull-right m-1">
    </div>
    ```

    > We have taken the markup that was previously in the `@foreach` expression in the `Index.cshtml` view and moved it to the new partial view. I call the partial view using a partial element, using the name and model attributes to specify the name of the partial view and its view model. Using a partial view allows the same markup to be inserted into any view that needs to display a summary of a product.

##  4. <a name='Bibliography'></a>Bibliography


##  5. <a name='CreatingaCRUDController'></a>Creating a CRUD Controller

2. Add a new controller to the `Controllers` folder called `AdminController`

    ```C#
    public class AdminController : Controller
	{
		private IProductRepository repository;
		public AdminController(IProductRepository repo)
		{
			repository = repo;
		}
		public IActionResult Index()
		{
			return View(repository.Products);
		}
	}
    ```

5. Add the following unit test to the `MVCStore.Tests` project
    ```C#
    public class AdminControllerTests {
        [Fact]
        public void Index_Contains_All_Products() {
            // Arrange - create the mock repository
            Mock<IProductRepository> mock = new Mock<IProductRepository>();
            mock.Setup(m => m.Products).Returns(new Product[] {
                new Product {ProductID = 1, Name = "P1"},
                new Product {ProductID = 2, Name = "P2"},
                new Product {ProductID = 3, Name = "P3"},
            }.AsQueryable<Product>());
            // Arrange - create a controller
            AdminController target = new AdminController(mock.Object);
            // Action
            Product[] result
                = GetViewModel<IEnumerable<Product>>(target.Index())?.ToArray();
            // Assert
            Assert.Equal(3, result.Length);
            Assert.Equal("P1", result[0].Name);
            Assert.Equal("P2", result[1].Name);
            Assert.Equal("P3", result[2].Name);
        }
        private T GetViewModel<T>(IActionResult result) where T : class {
            return (result as ViewResult)?.ViewData.Model as T;
        }
    }
    ```
6. Run the unit test

##  6. <a name='ImplementingtheListView'></a>Implementing the List View

7. In the Views/Admin folder add a Razor file called Index.cshtml

    ```CSHTML
    @model IEnumerable<Product>

    @{
        ViewBag.Title = "All Products";
    }

    <h1>Products</h1>

    <a asp-action="Create" class="btn btn-primary mb-3">Add Product</a>

    <table class="table table-striped table-bordered table-sm">
        <tr>
            <th class="text-right">ID</th>
            <th>Name</th>
            <th class="text-right">Price</th>
            <th class="text-center">Actions</th>
        </tr>
        @foreach (var item in Model)
        {
            <tr>
                <td class="text-right">@item.ProductId</td>
                <td>@item.Name</td>
                <td class="text-right">@item.Price</td>
                <td class="text-center">
                    <a asp-action="Edit" class="btn btn-sm btn-warning"
                        asp-route-productId="@item.ProductId">
                        Edit
                    </a>
                    <form asp-action="Delete" method="post">
                        <input type="hidden" name="ProductId" value="@item.ProductId" />
                        <button type="submit" class="btn btn-danger btn-sm">
                            Delete
                        </button>
                    </form>
                </td>
            </tr>
        }
    </table>
    ```

##  7. <a name='EditingProducts'></a>Editing Products

1. Add an `Edit` action on the `AdminController` 

    ```C#
    public IActionResult Edit(int productId)
    {
        var product = repository.Products.FirstOrDefault(p => p.ProductId == productId);
        return View(product);
    }
    ```

2. Scaffold the corresponding view. Update the content of the view as follows:

    ```HTML
    @model MVCStore.Models.Product

    @{
        ViewData["Title"] = "Edit";
    }

    <h1>Edit product</h1>
    <hr />

    <form asp-action="Edit">
        <div asp-validation-summary="ModelOnly" class="text-danger"></div>
        <input type="hidden" asp-for="ProductId" />
        <div class="form-group">
            <label asp-for="Name" class="control-label"></label>
            <input asp-for="Name" class="form-control" />
            <span asp-validation-for="Name" class="text-danger"></span>
        </div>
        <div class="form-group">
            <label asp-for="Description" class="control-label"></label>
            <input asp-for="Description" class="form-control" />
            <span asp-validation-for="Description" class="text-danger"></span>
        </div>
        <div class="form-group">
            <label asp-for="Price" class="control-label"></label>
            <input asp-for="Price" class="form-control" />
            <span asp-validation-for="Price" class="text-danger"></span>
        </div>
        <div class="form-group text-right">
            <input type="submit" value="Save" class="btn btn-primary" />
            <a asp-action="Index" class="btn btn-secondary">Back to List</a>
        </div>
    </form>
    ```

3. Add a `SaveProduct` method in the `IProductRepository` interface.
    ```C#
    public interface IProductRepository
	{
		IEnumerable<Product> Products { get; }

		Task SaveProductAsync(Product product);
	}
    ```

4. Implement the `SaveProduct` method as follows.
    ```C#
    public async Task SaveProductAsync(Product product)
    {
        if (product.ProductId == 0)
        {
            context.Products.Add(product);
        }
        else
        {
            Product dbEntry = context.Products
                .FirstOrDefault(p => p.ProductId == product.ProductId);
            if (dbEntry != null)
            {
                dbEntry.Name = product.Name;
                dbEntry.Description = product.Description;
                dbEntry.Price = product.Price;
            }
        }
        await context.SaveChangesAsync();
    }
    ```

##  8. <a name='HandlingEditPOSTRequests'></a>Handling Edit POST Requests

1. Add the `Edit` action that will handle POST requests on the `AdminController`

    ```C#
    [HttpPost]
    public async Task<IActionResult> Edit(Product product)
    {
        if (ModelState.IsValid)
        {
            await repository.SaveProductAsync(product);
            TempData["message"] = $"{product.Name} has been saved";
            return RedirectToAction("Index");
        }
        else
        {
            // there is something wrong with the data values 
            return View(product);
        }
    }
    ```

    > Notice the `TempData` object

2. Update the `Layout.cshtml` layout file in order to display the confirmation message.

    ```CSHTML
    @if (TempData["message"] != null)
    {
        <div class="alert alert-success">@TempData["message"]</div>
    }
    ```

##  9. <a name='Addingmodelvalidation'></a>Adding model validation

1. Update the `Product` class as follows.

    ```C#
    public class Product {
        public int ProductID { get; set; }
        [Required(ErrorMessage = "Please enter a product name")] 
        public string Name { get; set; }
        [Required(ErrorMessage = "Please enter a description")] 
        public string Description { get; set; }
        [Required] 
        [Range(0.01, double.MaxValue, 
            ErrorMessage = "Please enter a positive price")] 
        public decimal Price { get; set; }
    }
    ```

##  10. <a name='CreatingNewProducts'></a>Creating New Products

1. Add a `Create` action to the `AdminController` class.

    ```C#
    public IActionResult Create(){
        return View("Edit", new Product());
    }  
    ```

##  11. <a name='DeletingProducts'></a>Deleting Products

1. Add a `DeleteProduct` method to the `IProductRepository` interface.

    ```C#
    Task<Product> DeleteProductAsync(int productID);
    ```

2. Implement the method in the `EFProductRepository` class.

    ```C#
    public async Task<Product> DeleteProductAsync(int productID) { 
        Product dbEntry = context.Products 
                .FirstOrDefault(p => p.ProductID == productID); 
    
        if (dbEntry != null) { 
            context.Products.Remove(dbEntry); 
            await context.SaveChangesAsync(); 
        } 
    
        return dbEntry; 
    } 
    ```
3. Add the corresponding action to the `AdminController`

    ```C#
    [HttpPost] 
    public async Task<IActionResult> Delete(int productId) { 
        Product deletedProduct = repository.DeleteProductAsync(productId); 
        if (deletedProduct != null) { 
            TempData["message"] = $"{deletedProduct.Name} was deleted"; 
        } 
        return RedirectToAction("Index"); 
    } 
    ```

4. Add a test method

    ```C#
    [Fact]
    public void Can_Delete_Valid_Products() {
        // Arrange - create a Product
        Product prod = new Product { ProductID = 2, Name = "Test" };
        // Arrange - create the mock repository
        Mock<IProductRepository> mock = new Mock<IProductRepository>();
        mock.Setup(m => m.Products).Returns(new Product[] {
            new Product {ProductID = 1, Name = "P1"},
            prod,
            new Product {ProductID = 3, Name = "P3"},
        }.AsQueryable<Product>());
        // Arrange - create the controller
        AdminController target = new AdminController(mock.Object);
        // Act - delete the product
        target.Delete(prod.ProductID);
        // Assert - ensure that the repository delete method was
        // called with the correct Product
        mock.Verify(m => m.DeleteProductAsync(prod.ProductID));
    }
    ```